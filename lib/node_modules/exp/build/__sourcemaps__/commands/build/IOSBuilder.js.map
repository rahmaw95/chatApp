{"version":3,"sources":["commands/build/IOSBuilder.js"],"names":["sharedQuestions","teamId","type","name","message","validate","val","p12Path","stat","stats","isFile","console","log","filter","isAbsolute","resolve","p12Password","password","length","IOSBuilder","getPublishInfoAsync","projectDir","args","username","experienceName","remoteFullPackageName","bundleIdentifier","bundleIdentifierIOS","INVALID_OPTIONS","checkStatus","options","collectAndValidateCredentials","error","publish","publishedExpIds","build","replyAttempt","result","reason","rawDump","Error","metadata","askForAppleId","askForTeamId","creds","validateCredentialsProduceTeamId","checkCredsAttempt","_throwIfFailureWithReasonDump","produceCerts","produceCertAttempt","p12password","p12","privateSigningKey","ensureAppIdLocally","checkAppExistenceAttempt","startsWith","createAppOnPortal","appId","features","enabledFeatures","producePushCerts","producePushCertsAttempt","privateSigningKeyPushCert","pushP12","pushP12password","produceProvisionProfile","produceProvisionProfileAttempt","provisioningProfile","freshCreds","certP12","certPassword","clientExpMadeCerts","updateCredentialsForPlatform","_fullLocalAuthRun","userCreds","credentials","undefined","cleanUp","credentialMetadata","platform","credentialsExistForPlatformAsync","existingCredentials","localAuth","clearCredentials","removeCredentialsForPlatform","_localCollectAndValidateCredentials","expertAuth","hasTeamId","hasCert","hasPushCert","hasProfile","credsToUpload","prompt","answers","readFile","pathToP12","p12Data","toString","pushPassword","profilePath","profileData","hasAppleId","appleId","validateCredentialsForPlatform","askForCerts","ensureAppId","CREDENTIAL_ERROR","askForPushCerts","opts","questions","push","choices","value","when","manageCertificates","fetchAppleCertificates","managePushCertificates","fetchPushCertificates"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;;;AAEA,IAAMA,kBAAkB;AACtBC,UAAQ;AACNC,UAAM,OADA;AAENC,UAAM,QAFA;AAGNC,6HAHM;AAINC,cAAU;AAAA,aAAOC,QAAQ,EAAf;AAAA;AAJJ,GADc;AAOtBC,WAAS;AACPL,UAAM,OADC;AAEPC,UAAM,WAFC;AAGPC,aAAS,mBAHF;AAIPC;AAAA,gJAAU,iBAAME,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAEc,sCAAGC,IAAH,CAAQD,OAAR,CAFd;;AAAA;AAEAE,qBAFA;AAAA,iDAGCA,MAAMC,MAAN,EAHD;;AAAA;AAAA;AAAA;;AAKN;AACAC,wBAAQC,GAAR,CAAY,wBAAZ;AANM,iDAOC,KAPD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAV;;AAAA;AAAA;AAAA;AAAA,OAJO;AAcPC,YAAQ,yBAAW;AACjBN,gBAAU,+CAAUA,OAAV,CAAV;AACA,UAAI,CAAC,cAAKO,UAAL,CAAgBP,OAAhB,CAAL,EAA+B;AAC7BA,kBAAU,cAAKQ,OAAL,CAAaR,OAAb,CAAV;AACD;AACD,aAAOA,OAAP;AACD;AApBM,GAPa;AA6BtBS,eAAa;AACXd,UAAM,UADK;AAEXC,UAAM,aAFK;AAGXC,aAAS,eAHE;AAIXC,cAAU;AAAA,aAAYY,SAASC,MAAT,GAAkB,CAA9B;AAAA;AAJC;AA7BS,CAAxB;;AAqCA;;;;;;;;;;;;;;;;;;;;IAmBqBC,U;;;;;;;;;;;;;;;;;;;uBASP,0BAAIC,mBAAJ,CAAwB,KAAKC,UAA7B,C;;;;mCALRC,I;AACEC,wB,cAAAA,Q;AACuBC,8B,cAAvBC,qB;AACqBC,gC,cAArBC,mB;;oBAICD,gB;;;;;sBACG,mCACJ,gCAAUE,eADN,6I;;;;uBAOF,KAAKC,WAAL,E;;;sBAEF,KAAKC,OAAL,CAAa5B,IAAb,KAAsB,W;;;;;;;uBAEhB,KAAK6B,6BAAL,CAAmCR,QAAnC,EAA6CC,cAA7C,EAA6DE,gBAA7D,C;;;;;;;;;;AAEN,8CAAIM,KAAJ,CACE,qFADF;;;;;uBAO0B,KAAKC,OAAL,E;;;AAAxBC,+B;;uBAEA,KAAKC,KAAL,CAAWD,eAAX,EAA4B,KAA5B,C;;;;;;;;;;;;;;;;;;kDAGsBE,Y,EAAc;AAC1C,UAAIA,aAAaC,MAAb,KAAwB,SAA5B,EAAuC;AAAA,YAC7BC,MAD6B,GACTF,YADS,CAC7BE,MAD6B;AAAA,YACrBC,OADqB,GACTH,YADS,CACrBG,OADqB;;AAErC,cAAM,IAAIC,KAAJ,aAAoBF,MAApB,cAAmC,+CAAeC,OAAf,CAAnC,CAAN;AACD;AACF;;AAED;AACA;;;;;mKACwBE,Q;;;;;;;;uBACc,KAAKC,aAAL,CAAmB,EAAEC,cAAc,KAAhB,EAAnB,C;;;AAA9BC,qB;;AACN,mDAAI,2BAAJ;;uBACgC,wBAAUC,gCAAV,CAA2CD,KAA3C,EAAkDH,QAAlD,C;;;AAA1BK,iC;;AACN,qBAAKC,6BAAL,CAAmCD,iBAAnC;AACQ7C,sB,GAAW6C,iB,CAAX7C,M;;AACR,mDAAI,0BAAJ;;uBACiC,wBAAU+C,YAAV,CAAuBJ,KAAvB,EAA8B3C,MAA9B,C;;;AAA3BgD,kC;;AACN,qBAAKF,6BAAL,CAAmCE,kBAAnC;AACQC,2B,GAAwCD,kB,CAAxCC,W,EAAaC,G,GAA2BF,kB,CAA3BE,G,EAAKC,iB,GAAsBH,kB,CAAtBG,iB;;AAC1B,mDAAI,8DAAJ;;uBACqC,wBAAUC,kBAAV,CAA6BT,KAA7B,EAAoCH,QAApC,EAA8CxC,MAA9C,C;;;AAAjCqD,wC;;sBAEFA,yBAAyBjB,MAAzB,KAAoC,SAApC,IACAiB,yBAAyBhB,MAAzB,CAAgCiB,UAAhC,CAA2C,sCAA3C,C;;;;;;uBAEiC,wBAAUC,iBAAV,CAA4BZ,KAA5B,EAAmCH,QAAnC,EAA6CxC,MAA7C,C;;;AAAjCqD,wC;;;AAEF,qBAAKP,6BAAL,CAAmCO,wBAAnC;wCAC6CA,wB,EAArCG,K,yBAAAA,K,EAAOC,Q,yBAAAA,Q,EAAUC,e,yBAAAA,e;;AACzB,mDAAI,+BAAJ;;uBACsC,wBAAUC,gBAAV,CAA2BhB,KAA3B,EAAkCH,QAAlC,EAA4CxC,MAA5C,C;;;AAAhC4D,uC;;AACN,qBAAKd,6BAAL,CAAmCc,uBAAnC;AAEqBC,yC,GAGjBD,uB,CAHFT,iB,EACAW,O,GAEEF,uB,CAFFE,O,EACAC,e,GACEH,uB,CADFG,e;;;AAGF,mDAAI,kCAAJ;;uBAC6C,wBAAUC,uBAAV,CAC3CrB,KAD2C,EAE3CH,QAF2C,EAG3CxC,MAH2C,C;;;AAAvCiE,8C;;AAKN,qBAAKnB,6BAAL,CAAmCmB,8BAAnC;AACQC,mC,GAAwBD,8B,CAAxBC,mB;AACFC,0B,GAAa;AACjBnE,gCADiB;AAEjBoE,2BAASlB,GAFQ;AAGjBmB,gCAAcpB,WAHG;AAIjBa,kCAJiB;AAKjBC,kDALiB;AAMjBG,0DANiB;AAOjBV,8BAPiB;AAQjBC,4BAAU,+CAAeA,QAAf,CARO;AASjBC,mCAAiB,+CAAeA,eAAf,CATA;AAUjBP,sDAViB;AAWjBU,sEAXiB;AAYjBS,sCAAoB;AAZH,iB;;AAcnB,mDAAI,mCAAJ;;uBACM,kCAAYC,4BAAZ,CAAyC,KAAzC,EAAgDJ,UAAhD,EAA4D3B,QAA5D,C;;;;;;;;;;;;;;;;;;;mKAGkCG,K,EAAwBH,Q;;;;;;;;oBAGzDG,K;;;;;;uBACU,KAAK6B,iBAAL,CAAuBhC,QAAvB,C;;;;;;sBAET,CAACG,MAAMyB,OAAP,IAAkB,CAACzB,MAAMmB,OAAzB,IAAoC,CAACnB,MAAMuB,mB;;;;;;uBACL,KAAKzB,aAAL,CAAmB,EAAEC,cAAc,IAAhB,EAAnB,C;;;AAAlC+B,yB;AACFC,2B,GAAc,E;;sBACd/B,MAAMyB,OAAN,KAAkBO,S;;;;;AACpB,mDAAI,0BAAJ;;uBACiC,wBAAU5B,YAAV,CAAuB0B,SAAvB,EAAkCA,UAAUzE,MAA5C,C;;;AAA3BgD,kC;;AACN,qBAAKF,6BAAL,CAAmCE,kBAAnC;AACQC,2B,GAAwCD,kB,CAAxCC,W,EAAaC,G,GAA2BF,kB,CAA3BE,G,EAAKC,iB,GAAsBH,kB,CAAtBG,iB;;AAC1BuB,8EACKA,WADL;AAEEN,2BAASlB,GAFX;AAGEmB,gCAAcpB;AAHhB;;;sBAMEN,MAAMmB,OAAN,KAAkBa,S;;;;;;uBACkB,wBAAUhB,gBAAV,CACpCc,SADoC,EAEpCjC,QAFoC,EAGpCiC,UAAUzE,MAH0B,C;;;AAAhC4D,uC;;AAKN,qBAAKd,6BAAL,CAAmCc,uBAAnC;AAEqBC,yC,GAGjBD,uB,CAHFT,iB,EACAW,O,GAEEF,uB,CAFFE,O,EACAC,e,GACEH,uB,CADFG,e;;AAEFW,8EACKA,WADL;AAEEZ,kCAFF;AAGEC;AAHF;;;sBAMEpB,MAAMuB,mBAAN,KAA8BS,S;;;;;;uBACa,wBAAUX,uBAAV,CAC3CS,SAD2C,EAE3CjC,QAF2C,EAG3CiC,UAAUzE,MAHiC,C;;;AAAvCiE,8C;;AAKN,qBAAKnB,6BAAL,CAAmCmB,8BAAnC;AACQC,mC,GAAwBD,8B,CAAxBC,mB;;AACRQ,8EACKA,WADL;AAEER;AAFF;;;AAKFQ,8EAAmBA,WAAnB,IAAgCJ,oBAAoB,MAApD;;uBACM,kCAAYC,4BAAZ,CAAyC,KAAzC,EAAgDG,WAAhD,EAA6DlC,QAA7D,C;;;;;;;;;;;;;;uBAMJ,wBAAUoC,OAAV,E;;;;;;;;;;;;;;;;;;;;;;mKAKRtD,Q,EACAC,c,EACAE,gB;;;;;;;;;AAEMoD,kC,GAAqB;AACzBvD,oCADyB;AAEzBC,gDAFyB;AAGzBE,oDAHyB;AAIzBqD,4BAAU;AAJe,iB;;AAM3B,mDAAI,4CAAJ;;uBACmD,kCAAYC,gCAAZ,CACjDF,kBADiD,C;;;AAA7CG,mC;;qBAIF,KAAKnD,OAAL,CAAaoD,S;;;;;qBACX,KAAKpD,OAAL,CAAaqD,gB;;;;;;uBACT,kCAAYC,4BAAZ,CAAyC,KAAzC,EAAgDN,kBAAhD,C;;;;uBAEK,KAAKO,mCAAL,CACXJ,mBADW,EAEXH,kBAFW,C;;;;;;qBAIJ,KAAKhD,OAAL,CAAawD,U;;;;;AACtB;;AAUIC,yB,WAAWC,O,WAASC,W,WAAaC,U;;AACrC,oBAAI,KAAK5D,OAAL,CAAaqD,gBAAb,IAAiC,CAACF,mBAAtC,EAA2D;AACzDM,8BAAY,KAAZ;AACAC,4BAAU,KAAV;AACAC,gCAAc,KAAd;AACAC,+BAAa,KAAb;AACD,iBALD,MAKO,IAAIT,mBAAJ,EAAyB;AAC9BM,8BAAY,CAAC,CAACN,oBAAoBhF,MAAlC;AACAuF,4BAAU,CAAC,CAACP,oBAAoBZ,OAAhC;AACAoB,gCAAc,CAAC,CAACR,oBAAoBlB,OAApC;AACA2B,+BAAa,CAAC,CAACT,oBAAoBd,mBAAnC;AACD;;AAEKwB,6B,GAAgC;AACpCpB,sCAAoB;AADgB,iB;;oBAIjCgB,S;;;;;;uBACsB,wCAASK,MAAT,CAAgB,CAAE5F,gBAAgBC,MAAlB,CAAhB,C;;;;AAAjBA,sB,SAAAA,M;;AACR0F,8BAAc1F,MAAd,GAAuBA,MAAvB;;;oBAGGuF,O;;;;;AACH,mDAAI,mDAAJ;;uBACsB,wCAASI,MAAT,CAAgB,CACpC5F,gBAAgBO,OADoB,EACXP,gBAAgBgB,WADL,CAAhB,C;;;AAAhB6E,uB;;uBAIgB,sCAAGC,QAAH,CAAYD,QAAQE,SAApB,C;;;AAAhBC,uB;;AACNL,8BAActB,OAAd,GAAwB2B,QAAQC,QAAR,CAAiB,QAAjB,CAAxB;AACAN,8BAAcrB,YAAd,GAA6BuB,QAAQ7E,WAArC;;;oBAGGyE,W;;;;;AACH,mDAAI,4DAAJ;;uBACsB,wCAASG,MAAT,CAAgB,CACpC5F,gBAAgBO,OADoB,EACXP,gBAAgBgB,WADL,CAAhB,C;;;AAAhB6E,wB;;uBAIgB,sCAAGC,QAAH,CAAYD,SAAQE,SAApB,C;;;AAAhBC,wB;;AACNL,8BAAc5B,OAAd,GAAwBiC,SAAQC,QAAR,CAAiB,QAAjB,CAAxB;AACAN,8BAAcO,YAAd,GAA6BL,SAAQ7E,WAArC;;;oBAGG0E,U;;;;;;uBAC2B,wCAASE,MAAT,CAAgB,CAAC;AAC7C1F,wBAAM,OADuC;AAE7CC,wBAAM,aAFuC;AAG7CC,2BAAS,gFAHoC;AAI7CC;AAAA,+JAAU,kBAAM8F,WAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qCAEc,sCAAG3F,IAAH,CAAQ2F,WAAR,CAFd;;AAAA;AAEA1F,mCAFA;AAAA,gEAGCA,MAAMC,MAAN,EAHD;;AAAA;AAAA;AAAA;;AAKN;AACAC,sCAAQC,GAAR,CAAY,wBAAZ;AANM,gEAOC,KAPD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAV;;AAAA;AAAA;AAAA;AAAA,qBAJ6C;AAc7CC,0BAAQ,6BAAe;AACrBsF,kCAAc,+CAAUA,WAAV,CAAd;AACA,wBAAI,CAAC,cAAKrF,UAAL,CAAgBqF,WAAhB,CAAL,EAAmC;AACjCA,oCAAc,cAAKpF,OAAL,CAAaoF,WAAb,CAAd;AACD;AACD,2BAAOA,WAAP;AACD;AApB4C,iBAAD,CAAhB,C;;;;AAAtBA,2B,SAAAA,W;;uBAuBkB,sCAAGL,QAAH,CAAYK,WAAZ,C;;;AAApBC,2B;;AACNT,8BAAcxB,mBAAd,GAAoCiC,YAAYH,QAAZ,CAAqB,QAArB,CAApC;;;;uBAGI,kCAAYzB,4BAAZ,CAAyC,KAAzC,EAAgDmB,aAAhD,EAA+Db,kBAA/D,C;;;;;;;AAGN;AACIuB,0B,WAAYb,Q,WAASC,Y;;AACzB,oBAAI,KAAK3D,OAAL,CAAaqD,gBAAb,IAAiC,CAACF,mBAAtC,EAA2D;AACzDoB,+BAAa,KAAb;AACAb,6BAAU,KAAV;AACAC,iCAAc,KAAd;AACD,iBAJD,MAIO,IAAIR,mBAAJ,EAAyB;AAC9BoB,+BAAa,CAAC,CAACpB,oBAAoBqB,OAAnC;AACAd,6BAAU,CAAC,CAACP,oBAAoBZ,OAAhC;AACAoB,iCAAc,CAAC,CAACR,oBAAoBlB,OAApC;AACD;;oBAEIsC,U;;;;;;uBACuB,KAAK3D,aAAL,CAAmB,EAAEC,cAAc,IAAhB,EAAnB,C;;;AAApBgC,2B;;AACN,mDAAI,iCAAJ;;uBACM,kCAAY4B,8BAAZ,CACJ,KADI,EAEJ,SAFI,EAGJ5B,WAHI,EAIJG,kBAJI,C;;;;uBAMA,kCAAYN,4BAAZ,CAAyC,KAAzC,EAAgDG,WAAhD,EAA6DG,kBAA7D,C;;;;;;;AAEN,mDAAI,iCAAJ;;uBACM,kCAAYyB,8BAAZ,CACJ,KADI,EAEJ,SAFI,EAGJ,IAHI,EAIJzB,kBAJI,C;;;AAOR,mDAAI,oBAAJ;;oBAEKU,Q;;;;;;uBACG,KAAKgB,WAAL,CAAiB1B,kBAAjB,C;;;;;;;AAEN,mDAAI,wCAAJ;;uBACM,kCAAYyB,8BAAZ,CAA2C,KAA3C,EAAkD,MAAlD,EAA0D,IAA1D,EAAgEzB,kBAAhE,C;;;;;AAKN,mDAAI,sBAAJ;;uBACM,kCAAY2B,WAAZ,CAAwB3B,kBAAxB,C;;;;;;;;;sBAEA,mCACJ,gCAAU4B,gBADN,6FAEoF5B,mBAAmBpD,gBAFvG,+D;;;oBAKH+D,Y;;;;;;uBACG,KAAKkB,eAAL,CAAqB7B,kBAArB,C;;;;;;;AAEN,mDAAI,gCAAJ;;uBACM,kCAAYyB,8BAAZ,CAA2C,KAA3C,EAAkD,MAAlD,EAA0D,IAA1D,EAAgEzB,kBAAhE,C;;;;;;;;;;;;;;;;;;;oKAKQ8B,I;;;;;;AAClB;AACAjG,wBAAQC,GAAR,CAAY,EAAZ;AACAD,wBAAQC,GAAR,CACE,oHADF;AAGMiG,yB,GAAY,CAChB;AACE3G,wBAAM,OADR;AAEEC,wBAAM,SAFR;AAGEC,mDAHF;AAIEC,4BAAU;AAAA,2BAAOC,QAAQ,EAAf;AAAA;AAJZ,iBADgB,EAOhB;AACEJ,wBAAM,UADR;AAEEC,wBAAM,UAFR;AAGEC,sCAHF;AAIEC,4BAAU;AAAA,2BAAOC,QAAQ,EAAf;AAAA;AAJZ,iBAPgB,C;;AAclB,oBAAIsG,KAAKjE,YAAT,EAAuB;AACrBkE,4BAAUC,IAAV,CAAe9G,gBAAgBC,MAA/B;AACD;;uBACqB,wCAAS2F,MAAT,CAAgBiB,SAAhB,C;;;AAAhBhB,uB;AAEAlB,2B,GAA8B;AAClC2B,2BAAST,QAAQS,OADiB;AAElCrF,4BAAU4E,QAAQ5E,QAFgB;AAGlChB,0BAAQ4F,QAAQ5F;AAHkB,iB;kDAK7B0E,W;;;;;;;;;;;;;;;;;;;oKAGSG,kB;;;;;;AAChB;AACAnE,wBAAQC,GAAR;;AAEMiG,yB,GAAY,CAChB;AACE3G,wBAAM,SADR;AAEEC,wBAAM,oBAFR;AAGEC,0JAHF;AAIE2G,2BAAS,CACP,EAAE5G,MAAM,8BAAR,EAAwC6G,OAAO,IAA/C,EADO,EAEP,EAAE7G,MAAM,sCAAR,EAAgD6G,OAAO,KAAvD,EAFO;AAJX,iBADgB,kDAWXhH,gBAAgBO,OAXL;AAYd0G,wBAAM;AAAA,2BAAW,CAACpB,QAAQqB,kBAApB;AAAA;AAZQ,oEAeXlH,gBAAgBgB,WAfL;AAgBdiG,wBAAM;AAAA,2BAAW,CAACpB,QAAQqB,kBAApB;AAAA;AAhBQ,mB;;uBAoBI,wCAAStB,MAAT,CAAgBiB,SAAhB,C;;;AAAhBhB,uB;;qBAEFA,QAAQqB,kB;;;;;AACV;AACA,mDAAI,wCAAJ;;uBACM,kCAAYC,sBAAZ,CAAmCrC,kBAAnC,C;;;;;;;;uBAGgB,sCAAGgB,QAAH,CAAYD,QAAQE,SAApB,C;;;AAAhBC,uB;AACArB,2B,GAAc;AAClBN,2BAAS2B,QAAQC,QAAR,CAAiB,QAAjB,CADS;AAElB3B,gCAAcuB,QAAQ7E;AAFJ,iB;;AAIpB,mDAAI,wCAAJ;;uBACM,kCAAYuF,8BAAZ,CACJ,KADI,EAEJ,MAFI,EAGJ5B,WAHI,EAIJG,kBAJI,C;;;;uBAMA,kCAAYN,4BAAZ,CAAyC,KAAzC,EAAgDG,WAAhD,EAA6DG,kBAA7D,C;;;;AAGR,mDAAI,0CAAJ;;;;;;;;;;;;;;;;;;;oKAGoBA,kB;;;;;;AACpB;;AAEM+B,yB,GAAY,CAChB;AACE3G,wBAAM,SADR;AAEEC,wBAAM,wBAFR;AAGEC,oKAHF;AAIE2G,2BAAS,CACP,EAAE5G,MAAM,8BAAR,EAAwC6G,OAAO,IAA/C,EADO,EAEP,EAAE7G,MAAM,sCAAR,EAAgD6G,OAAO,KAAvD,EAFO;AAJX,iBADgB,kDAWXhH,gBAAgBO,OAXL;AAYd0G,wBAAM;AAAA,2BAAW,CAACpB,QAAQuB,sBAApB;AAAA;AAZQ,oEAeXpH,gBAAgBgB,WAfL;AAgBdiG,wBAAM;AAAA,2BAAW,CAACpB,QAAQuB,sBAApB;AAAA;AAhBQ,mB;;uBAwBR,wCAASxB,MAAT,CAAgBiB,SAAhB,C;;;AAJJhB,uB;;qBAMFA,QAAQuB,sB;;;;;AACV;AACA,mDAAI,oCAAJ;;uBACM,kCAAYC,qBAAZ,CAAkCvC,kBAAlC,C;;;;;;;;uBAGgB,sCAAGgB,QAAH,CAAYD,QAAQE,SAApB,C;;;AAAhBC,uB;AAEArB,2B,GAA8B;AAClCZ,2BAASiC,QAAQC,QAAR,CAAiB,QAAjB,CADyB;AAElCC,gCAAcL,QAAQ7E;AAFY,iB;;;AAKpC,mDAAI,gCAAJ;;uBACM,kCAAYuF,8BAAZ,CACJ,KADI,EAEJ,MAFI,EAGJ5B,WAHI,EAIJG,kBAJI,C;;;;uBAMA,kCAAYN,4BAAZ,CAAyC,KAAzC,EAAgDG,WAAhD,EAA6DG,kBAA7D,C;;;AAER,mDAAI,kCAAJ;;;;;;;;;;;;;;;;;;;;kBAldiB3D,U","file":"../../../commands/build/IOSBuilder.js","sourcesContent":["/**\n * @flow\n */\n\nimport fs from 'fs-extra';\nimport path from 'path';\nimport inquirer from 'inquirer';\nimport untildify from 'untildify';\nimport { Exp, Credentials, XDLError, ErrorCode } from 'xdl';\n\nimport type { IOSCredentials, CredentialMetadata } from 'xdl/src/Credentials';\nimport BaseBuilder from './BaseBuilder';\nimport log from '../../log';\n\nimport * as authFuncs from '../../local-auth/auth';\n\nconst sharedQuestions = {\n  teamId: {\n    type: 'input',\n    name: 'teamId',\n    message: `What is your Apple Team ID (you can find that on this page: https://developer.apple.com/account/#/membership)?`,\n    validate: val => val !== '',\n  },\n  p12Path: {\n    type: 'input',\n    name: 'pathToP12',\n    message: 'Path to P12 file:',\n    validate: async p12Path => {\n      try {\n        const stats = await fs.stat(p12Path);\n        return stats.isFile();\n      } catch (e) {\n        // file does not exist\n        console.log('\\nFile does not exist.');\n        return false;\n      }\n    },\n    filter: p12Path => {\n      p12Path = untildify(p12Path);\n      if (!path.isAbsolute(p12Path)) {\n        p12Path = path.resolve(p12Path);\n      }\n      return p12Path;\n    },\n  },\n  p12Password: {\n    type: 'password',\n    name: 'p12Password',\n    message: 'P12 password:',\n    validate: password => password.length > 0,\n  },\n};\n\n/**\n * Steps:\n * 1) Check for active builds -- only one build per user/experience can happen at once\n * 2) Check for Apple ID credentials for this user/experience\n * \t\ta) If they don't exist, prompt user to enter them. Submit them to server (/-/api/credentials/add),\n * \t\t\t which will verify and store them.\n * 3) Check for valid cert for this user/experience\n * \t\ta) If valid cert doesn't exist, prompt user:\n * \t \t\t\ti) Do you have a certificate you'd like to use for signing this application, or would you like us\n * \t \t\t\t\t to generate them for you?\n * \t \t\t\t\t This is most common when you have other apps in the App Store, you're replacing an existing\n * \t \t\t\t\t app in the App Store with an Exponent app, or you'd simply like more control over your Apple\n * \t \t\t\t\t Developer account.\n * \t \t    ii) If they choose to upload a cert, ask them for the path to .p12 file. Upload the p12 (/-/api/credentials/add).\n * \t \t    iii) If they want us to manage it, call to /-/api/credentials/generate-certs, and verify that we were able to generate the cert\n * \t \tb) If a cert exists, the server will verify that it is still valid.\n * 4) Publish the experience from the local packager.\n * 5) Initiate build process.\n */\nexport default class IOSBuilder extends BaseBuilder {\n  async run() {\n    // validate bundleIdentifier before hitting the network to check build status\n    const {\n      args: {\n        username,\n        remoteFullPackageName: experienceName,\n        bundleIdentifierIOS: bundleIdentifier,\n      },\n    } = await Exp.getPublishInfoAsync(this.projectDir);\n\n    if (!bundleIdentifier) {\n      throw new XDLError(\n        ErrorCode.INVALID_OPTIONS,\n        `Your project must have a bundleIdentifier set in app.json. See https://docs.expo.io/versions/latest/guides/building-standalone-apps.html`\n      );\n    }\n\n    // Check the status of any current builds\n    await this.checkStatus();\n    // Check for existing credentials, collect any missing credentials, and validate them\n    if (this.options.type !== 'simulator') {\n      try {\n        await this.collectAndValidateCredentials(username, experienceName, bundleIdentifier);\n      } catch (e) {\n        log.error(\n          'Error validating credentials. You may need to clear them (with `-c`) and try again.'\n        );\n        throw e;\n      }\n    }\n    // Publish the experience\n    const publishedExpIds = await this.publish();\n    // Initiate the build with the published experience\n    await this.build(publishedExpIds, 'ios');\n  }\n\n  _throwIfFailureWithReasonDump(replyAttempt) {\n    if (replyAttempt.result === 'failure') {\n      const { reason, rawDump } = replyAttempt;\n      throw new Error(`Reason:${reason}, raw:${JSON.stringify(rawDump)}`);\n    }\n  }\n\n  // Getting an undefined anywhere here probably means a ruby script\n  // is throwing an exception\n  async _fullLocalAuthRun(metadata) {\n    const creds: IOSCredentials = await this.askForAppleId({ askForTeamId: false });\n    log('Validating Credentials...');\n    const checkCredsAttempt = await authFuncs.validateCredentialsProduceTeamId(creds, metadata);\n    this._throwIfFailureWithReasonDump(checkCredsAttempt);\n    const { teamId } = checkCredsAttempt;\n    log('Creating Certificates...');\n    const produceCertAttempt = await authFuncs.produceCerts(creds, teamId);\n    this._throwIfFailureWithReasonDump(produceCertAttempt);\n    const { p12password, p12, privateSigningKey } = produceCertAttempt;\n    log('Making sure that we have an AppID on the Developer Portal...');\n    let checkAppExistenceAttempt = await authFuncs.ensureAppIdLocally(creds, metadata, teamId);\n    if (\n      checkAppExistenceAttempt.result === 'failure' &&\n      checkAppExistenceAttempt.reason.startsWith('App could not be found for bundle id')\n    ) {\n      checkAppExistenceAttempt = await authFuncs.createAppOnPortal(creds, metadata, teamId);\n    }\n    this._throwIfFailureWithReasonDump(checkAppExistenceAttempt);\n    const { appId, features, enabledFeatures } = checkAppExistenceAttempt;\n    log('Creating Push Certificates...');\n    const producePushCertsAttempt = await authFuncs.producePushCerts(creds, metadata, teamId);\n    this._throwIfFailureWithReasonDump(producePushCertsAttempt);\n    const {\n      privateSigningKey: privateSigningKeyPushCert,\n      pushP12,\n      pushP12password,\n    } = producePushCertsAttempt;\n\n    log('Creating Provisioning Profile...');\n    const produceProvisionProfileAttempt = await authFuncs.produceProvisionProfile(\n      creds,\n      metadata,\n      teamId\n    );\n    this._throwIfFailureWithReasonDump(produceProvisionProfileAttempt);\n    const { provisioningProfile } = produceProvisionProfileAttempt;\n    const freshCreds = {\n      teamId,\n      certP12: p12,\n      certPassword: p12password,\n      pushP12,\n      pushP12password,\n      provisioningProfile,\n      appId,\n      features: JSON.stringify(features),\n      enabledFeatures: JSON.stringify(enabledFeatures),\n      privateSigningKey,\n      privateSigningKeyPushCert,\n      clientExpMadeCerts: 'true',\n    };\n    log('Updating credentials with expo...');\n    await Credentials.updateCredentialsForPlatform('ios', freshCreds, metadata);\n  }\n\n  async _localCollectAndValidateCredentials(creds: ?IOSCredentials, metadata: CredentialMetadata) {\n    try {\n      // In the case when user has no credentials at all, get everything\n      if (!creds) {\n        return await this._fullLocalAuthRun(metadata);\n      } else {\n        if (!creds.certP12 || !creds.pushP12 || !creds.provisioningProfile) {\n          const userCreds: IOSCredentials = await this.askForAppleId({ askForTeamId: true });\n          let credentials = {};\n          if (creds.certP12 === undefined) {\n            log('Creating Certificates...');\n            const produceCertAttempt = await authFuncs.produceCerts(userCreds, userCreds.teamId);\n            this._throwIfFailureWithReasonDump(produceCertAttempt);\n            const { p12password, p12, privateSigningKey } = produceCertAttempt;\n            credentials = {\n              ...credentials,\n              certP12: p12,\n              certPassword: p12password,\n            };\n          }\n          if (creds.pushP12 === undefined) {\n            const producePushCertsAttempt = await authFuncs.producePushCerts(\n              userCreds,\n              metadata,\n              userCreds.teamId\n            );\n            this._throwIfFailureWithReasonDump(producePushCertsAttempt);\n            const {\n              privateSigningKey: privateSigningKeyPushCert,\n              pushP12,\n              pushP12password,\n            } = producePushCertsAttempt;\n            credentials = {\n              ...credentials,\n              pushP12,\n              pushP12password,\n            };\n          }\n          if (creds.provisioningProfile === undefined) {\n            const produceProvisionProfileAttempt = await authFuncs.produceProvisionProfile(\n              userCreds,\n              metadata,\n              userCreds.teamId\n            );\n            this._throwIfFailureWithReasonDump(produceProvisionProfileAttempt);\n            const { provisioningProfile } = produceProvisionProfileAttempt;\n            credentials = {\n              ...credentials,\n              provisioningProfile,\n            };\n          }\n          credentials = { ...credentials, clientExpMadeCerts: 'true' };\n          await Credentials.updateCredentialsForPlatform('ios', credentials, metadata);\n        }\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      await authFuncs.cleanUp();\n    }\n  }\n\n  async collectAndValidateCredentials(\n    username: string,\n    experienceName: string,\n    bundleIdentifier: string\n  ) {\n    const credentialMetadata = {\n      username,\n      experienceName,\n      bundleIdentifier,\n      platform: 'ios',\n    };\n    log('Checking for existing Apple credentials...');\n    const existingCredentials: ?IOSCredentials = await Credentials.credentialsExistForPlatformAsync(\n      credentialMetadata\n    );\n\n    if (this.options.localAuth) {\n      if (this.options.clearCredentials) {\n        await Credentials.removeCredentialsForPlatform('ios', credentialMetadata);\n      }\n      return await this._localCollectAndValidateCredentials(\n        existingCredentials,\n        credentialMetadata\n      );\n    } else if (this.options.expertAuth) {\n      log(`\nWARNING! In expert auth mode, we won't be able to make sure your certificates,\nprovisioning profile, app ID, or team ID are valid. Please double check that you're\nuploading valid files for your app otherwise you may encounter strange errors!\n\nMake sure you've created your app ID on the developer portal, that your app ID\nis in app.json as \\`bundleIdentifier\\`, and that the provisioning profile you\nupload matches that team ID and app ID.\n`);\n\n      let hasTeamId, hasCert, hasPushCert, hasProfile;\n      if (this.options.clearCredentials || !existingCredentials) {\n        hasTeamId = false;\n        hasCert = false;\n        hasPushCert = false;\n        hasProfile = false;\n      } else if (existingCredentials) {\n        hasTeamId = !!existingCredentials.teamId;\n        hasCert = !!existingCredentials.certP12;\n        hasPushCert = !!existingCredentials.pushP12;\n        hasProfile = !!existingCredentials.provisioningProfile;\n      }\n\n      const credsToUpload: IOSCredentials = {\n        clientExpMadeCerts: 'true',\n      };\n\n      if (!hasTeamId) {\n        const { teamId } = await inquirer.prompt([ sharedQuestions.teamId, ]);\n        credsToUpload.teamId = teamId;\n      }\n\n      if (!hasCert) {\n        log('Please provide your distribution certificate P12:')\n        const answers = await inquirer.prompt([\n          sharedQuestions.p12Path, sharedQuestions.p12Password,\n        ]);\n\n        const p12Data = await fs.readFile(answers.pathToP12);\n        credsToUpload.certP12 = p12Data.toString('base64');\n        credsToUpload.certPassword = answers.p12Password;\n      }\n\n      if (!hasPushCert) {\n        log('Please provide the path to your push notification cert P12');\n        const answers = await inquirer.prompt([\n          sharedQuestions.p12Path, sharedQuestions.p12Password,\n        ]);\n\n        const p12Data = await fs.readFile(answers.pathToP12);\n        credsToUpload.pushP12 = p12Data.toString('base64');\n        credsToUpload.pushPassword = answers.p12Password;\n      }\n\n      if (!hasProfile) {\n        const { profilePath } = await inquirer.prompt([{\n          type: 'input',\n          name: 'profilePath',\n          message: 'Path to your provisioning profile which matches bundleIdentifer from app.json:',\n          validate: async profilePath => {\n            try {\n              const stats = await fs.stat(profilePath);\n              return stats.isFile();\n            } catch (e) {\n              // file does not exist\n              console.log('\\nFile does not exist.');\n              return false;\n            }\n          },\n          filter: profilePath => {\n            profilePath = untildify(profilePath);\n            if (!path.isAbsolute(profilePath)) {\n              profilePath = path.resolve(profilePath);\n            }\n            return profilePath;\n          },\n        }]);\n\n        const profileData = await fs.readFile(profilePath);\n        credsToUpload.provisioningProfile = profileData.toString('base64');\n      }\n\n      await Credentials.updateCredentialsForPlatform('ios', credsToUpload, credentialMetadata);\n\n    } else {\n      // TODO remove this entirely!!!\n      let hasAppleId, hasCert, hasPushCert;\n      if (this.options.clearCredentials || !existingCredentials) {\n        hasAppleId = false;\n        hasCert = false;\n        hasPushCert = false;\n      } else if (existingCredentials) {\n        hasAppleId = !!existingCredentials.appleId;\n        hasCert = !!existingCredentials.certP12;\n        hasPushCert = !!existingCredentials.pushP12;\n      }\n\n      if (!hasAppleId) {\n        const credentials = await this.askForAppleId({ askForTeamId: true });\n        log('Validating Apple credentials...');\n        await Credentials.validateCredentialsForPlatform(\n          'ios',\n          'appleId',\n          credentials,\n          credentialMetadata\n        );\n        await Credentials.updateCredentialsForPlatform('ios', credentials, credentialMetadata);\n      } else {\n        log('Validating Apple credentials...');\n        await Credentials.validateCredentialsForPlatform(\n          'ios',\n          'appleId',\n          null,\n          credentialMetadata\n        );\n      }\n      log('Credentials valid.');\n\n      if (!hasCert) {\n        await this.askForCerts(credentialMetadata);\n      } else {\n        log('Validating distribution certificate...');\n        await Credentials.validateCredentialsForPlatform('ios', 'cert', null, credentialMetadata);\n      }\n\n      // ensure that the app id exists or is created\n      try {\n        log('Validating app id...');\n        await Credentials.ensureAppId(credentialMetadata);\n      } catch (e) {\n        throw new XDLError(\n          ErrorCode.CREDENTIAL_ERROR,\n          `It seems like we can't create an app on the Apple developer center with this app id: ${credentialMetadata.bundleIdentifier}. Please change your bundle identifier to something else.`\n        );\n      }\n      if (!hasPushCert) {\n        await this.askForPushCerts(credentialMetadata);\n      } else {\n        log('Validating push certificate...');\n        await Credentials.validateCredentialsForPlatform('ios', 'push', null, credentialMetadata);\n      }\n    }\n  }\n\n  async askForAppleId(opts: { askForTeamId?: boolean }): Promise<IOSCredentials> {\n    // ask for creds\n    console.log('');\n    console.log(\n      'We need your Apple ID/password to manage certificates and provisioning profiles from your Apple Developer account.'\n    );\n    const questions = [\n      {\n        type: 'input',\n        name: 'appleId',\n        message: `What's your Apple ID?`,\n        validate: val => val !== '',\n      },\n      {\n        type: 'password',\n        name: 'password',\n        message: `Password?`,\n        validate: val => val !== '',\n      },\n    ];\n    if (opts.askForTeamId) {\n      questions.push(sharedQuestions.teamId);\n    }\n    const answers = await inquirer.prompt(questions);\n\n    const credentials: IOSCredentials = {\n      appleId: answers.appleId,\n      password: answers.password,\n      teamId: answers.teamId,\n    };\n    return credentials;\n  }\n\n  async askForCerts(credentialMetadata: CredentialMetadata) {\n    // ask about certs\n    console.log(``);\n\n    const questions = [\n      {\n        type: 'rawlist',\n        name: 'manageCertificates',\n        message: `Do you already have a distribution certificate you'd like us to use,\\nor do you want us to manage your certificates for you?`,\n        choices: [\n          { name: 'Let Expo handle the process!', value: true },\n          { name: 'I want to upload my own certificate!', value: false },\n        ],\n      },\n      {\n        ...sharedQuestions.p12Path,\n        when: answers => !answers.manageCertificates,\n      },\n      {\n        ...sharedQuestions.p12Password,\n        when: answers => !answers.manageCertificates,\n      },\n    ];\n\n    const answers = await inquirer.prompt(questions);\n\n    if (answers.manageCertificates) {\n      // Attempt to fetch new certificates\n      log('Generating distribution certificate...');\n      await Credentials.fetchAppleCertificates(credentialMetadata);\n    } else {\n      // Upload credentials\n      const p12Data = await fs.readFile(answers.pathToP12);\n      const credentials = {\n        certP12: p12Data.toString('base64'),\n        certPassword: answers.p12Password,\n      };\n      log('Validating distribution certificate...');\n      await Credentials.validateCredentialsForPlatform(\n        'ios',\n        'cert',\n        credentials,\n        credentialMetadata\n      );\n      await Credentials.updateCredentialsForPlatform('ios', credentials, credentialMetadata);\n    }\n\n    log('Distribution certificate setup complete.');\n  }\n\n  async askForPushCerts(credentialMetadata: CredentialMetadata) {\n    // ask about certs\n\n    const questions = [\n      {\n        type: 'rawlist',\n        name: 'managePushCertificates',\n        message: `Do you already have a push notification certificate you'd like us to use,\\nor do you want us to manage your push certificates for you?`,\n        choices: [\n          { name: 'Let Expo handle the process!', value: true },\n          { name: 'I want to upload my own certificate!', value: false },\n        ],\n      },\n      {\n        ...sharedQuestions.p12Path,\n        when: answers => !answers.managePushCertificates,\n      },\n      {\n        ...sharedQuestions.p12Password,\n        when: answers => !answers.managePushCertificates,\n      }\n    ];\n\n    const answers: {\n      managePushCertificates: boolean,\n      pathToP12?: string,\n      p12Password?: string,\n    } = await inquirer.prompt(questions);\n\n    if (answers.managePushCertificates) {\n      // Attempt to fetch new certificates\n      log('Fetching a new push certificate...');\n      await Credentials.fetchPushCertificates(credentialMetadata);\n    } else {\n      // Upload credentials\n      const p12Data = await fs.readFile(answers.pathToP12);\n\n      const credentials: IOSCredentials = {\n        pushP12: p12Data.toString('base64'),\n        pushPassword: answers.p12Password,\n      };\n\n      log('Validating push certificate...');\n      await Credentials.validateCredentialsForPlatform(\n        'ios',\n        'push',\n        credentials,\n        credentialMetadata\n      );\n      await Credentials.updateCredentialsForPlatform('ios', credentials, credentialMetadata);\n    }\n    log('Push certificate setup complete.');\n  }\n}\n"],"sourceRoot":"/Users/brentvatne/universe/dev/exp/src"}